\documentclass[a4paper]{thesis}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\hypersetup{pdfauthor={Patrick Pfeifer}}
\begin{document}
\input{titlepage}
\renewcommand\contentsname{Inhalt}
\tableofcontents
\listoftodos
\newpage
\section{Einleitung}
%        ==========
\subsection{Zusammenfassung}
%           ---------------
Die Vorliegende Arbeit beschreibt die Architektur und die
Anwendungsmöglichkeiten einer neuen Software zur Analyse von RNA-seq Daten.

Bei der RNA-seq - Methode, werden komplementäre DNAs (cDNAs), die aus den zu
untersuchenden RNAs hergestellt wurden, mit neuartigen (eng. next-generation)
Technologien sequenziert. \cite{ausubel_rna-seq:_2010}
%
Die Einführung dieser neuartiger Technologien der Gen-Sequenzierung
ist ein wichtiger Meilenstein auf dem Weg zu einem besseren und
tieferen Verständnis der Funktionsweise der Zellen. Bei der Durchführung
von RNA-seq Experimenten fallen grosse Mengen von Daten in Form von
relativ kurzen Sequenzabschnitten (< 200 Basen) an. Die Sequenzdaten
werden dann an die NCBI und andere zentrale Sequenzarchive (SRA -
Sequence Read Archive) übermittelt. Zum heutigen Tag sind bereits
grosse Mengen an Daten gesammelt worden, die nun öffentlich
online verfügbar sind.

Diese Daten werden mit der bereits bekannten
Genomsequenz verglichen um die Bereiche des Genoms zu finden,
die transkribiert werden. Transkription wird nicht für
alle Genombereiche erwartet, sondern nur dort, wo sich proteinkodierende
Abschnitte bzw. Gene für RNA-Moleküle befinden. Eine Analyse der RNA-Seq
Daten wird daher durch die Visualisierung der RNA-Seq Daten entscheidend
unterstützt. Darüber hinaus kann die Annotation eines Genoms durch die
Verfügbarkeit der Transkriptdaten verbessert werden.

Die in dieser Diplomarbeit programmierte Web-Anwendung wurde erstellt, um
die von RNA-seq
Experimenten generierten Daten in einer bereits existierenden, populären,
Visualisierungsanwendung, dem {\em UCSC Archaea Browser}
\cite{schneider_ucsc_2006}, anzuzeigen. Durch die Verwendung der von dieser
Anwendung unterstützten, bzw. definierten, Protokolle zur Formatierung
und Darstellung der Daten, stehen dem Anwender viele Funktionen zur
Verfügung, die sich mit einer gekapselten Desktop-Anwendung nur unter
grossem Aufwand realisieren liessen. So können die Daten im {\em UCSC Archaea
Browser} beispielsweise immer im Kontext mit den {\em aktuellen} RefSeq
Gen-Annotationen betrachtet werden.

\subsection{Motivation / Ziel}
%           -----------------
Der Fokus vieler RNA-seq Studien liegt in der Analyse von
eukaryontischen Transkriptomen. Die generierten Sequenzdaten sind z.B. sehr
hilfreich, um die unterschiedlichen Transkripte eines Gens zu erfassen.

Für die prinzipiell wesentlich einfachere Auswertung von RNA-seq Daten von
Prokaryonten stehen bisher keine geeigneten Auswerteprogramme zur Verfügung.

Die Programmierung einer solchen Software im Rahmen einer Bachelor-Thesis
bietet sich daher an. Zum einen erhalte ich als Student der Biomedizinischen
Informatik einen Einblick in die die Welt der Genforschung. Zum andern kann ich
hoffentlich mit meiner Arbeit einen kleinen Beitrag zur Verbesserung der
Zugänglichkeit zu der beeindruckenden Menge an RNA-Sequenzdaten leisten.

\subsection{Theoretischer Hintergrund}
%           -------------------------
Seit einiger Zeit bieten eine Handvoll Produzenten Gensequenzierungsanlagen an,
bei denen die Kosten pro sequenziertem Basenpaar
drastisch verringert werden konnten. Diese neuartigen
Sequenzierungs-Plattformen werden dazu verwendet, sowohl
das Genom wie auch das Transkriptom, also die gesamte RNA-Substanz die
in einer Zelle zu einem definierten Zeitpunkt vorhanden ist, zu sequenzieren.

Gegenüber der klassischen Transkritomanalyse mit Mikroarrays, bietet RNA-seq
den gewichtigen Vorteil, dass damit {\em alle} Abschnitte des Genoms
auf Transkription geprüft werden können.

Mit RNA-seq können darum - und das ist auch der Teil für den die vorliegende
Software eingesetzt werden soll - auch {\em neue Gene} gefunden bzw.
untranskribierte Bereiche erkannt werden,
wo bisher ein Gen vermutet wurde.
\cite{croucher_studying_2010}

Ein weiterer Vorteil von RNA-seq Technologien, ist die Möglichkeit,
das Expressionsniveau jeder einzelnen Base exakt messen zu können.
Indem die Anzahl der Reads bezüglich Ihrer Länge und der Länge des
Gens auf dem sie liegen normalisiert wird, werden
dadurch verschiedene Studien auch sehr gut miteinander vergleichbar.
\cite{croucher_studying_2010,wang_rna-seq:_2009}

\section{Technologie}
%        ===========

\subsection{Betriebssystem}
%           --------------

UNIX ist aus Entwicklersicht aus verschiedenen Gründen eine optimale
Betriebssystemplatform, um Datenintensive Berechnungen, wie sie bei
der Verarbeitung und Aufbereitung von RNA-seq Daten anfallen durchzuführen.
Die Architektur des Systems hat sich bewährt und ist weitherum bekannt
für Ihre Robustheit, Performanz.

So sind denn auch die meisten Programme, die in jüngster Vergangenheit
entwickelt wurden, um RNA-seq Daten zu verarbeiten, auf UNIX Umgebungen
programmiert worden und darum dort auch ohne Probleme lauffähig.

Für die Softwareentwicklung sind auf der UNIX Platform
eine Vielzahl verschiedener Programmbibliotheken und Sprachumgebungen
Verfügbar. Die Qualität variiert, doch der Wettbewerb selektiert
schlussendlich immer die guten.

Es wurde also ein UNIX Betriebssystem und zwar Debian GNU/Linux 6.0.4
(codename "squeeze") verwendet.

\subsection{Programmiersprache}
%           ------------------

Die Programmiersprache {\em Python}, für die im Jahre 1991 ein erster
Interpreter publiziert wurde und die in den letzten Jahren sehr
populär geworden ist, war schon gesetzt. Sie eignet sich besonders gut
für schnelle Entwicklung, da der
Quellcode nicht in einem separaten Schritt kompiliert werden muss und
darum geänderter Code viel schneller getestet werden kann.

\subsection{Testing}
%           -------

Das Testen einzelner Softwarekomponenten wird mit dem {\em unittest} modul
aus der {\em Python Standard Library} orchestriert. Das {\em nosetest}
Modul erweitert die Funktionalität des Standard Moduls noch.
Es erzeugt in Zusamenarbeit mit dem {\em coverage}
Programmpaket auf Befehl hin einen {\em Test Coverage Report}. Die
Test-Coverage lässt sich als Prozentzahl angeben. Sie gibt Auskunft darüber,
wie gross der Anteil der getesteten Code-Statements im Vergleich zur Gesamtzahl
von Code-Statements ist.

\subsection{weitere Bausteine}
%           -----------------

Bei der Auswahl der Technologien zur
Implementation der vorliegende Software,
habe ich versucht möglichst solche Bausteine und Bibliotheken
zu verwenden, die gut dokumentiert sind, eine möglichst grosse Anwenderbasis
haben und sich bereits möglichst lange im Wettbewerb behaupten konnten.

\setlength\LTleft{0pt}
\setlength\LTright{-5pt}
\begin{longtable}{@{\extracolsep{\fill}}p{\fill}p{0.8\textwidth}}

SQLite

	& Die SQLite Datenbank Engine (RDBMS) unterscheidet sich dadurch von
	allen anderen bekannten relationalen Datenbanken, wie MySQL,
	Postgres, etc., dass hier die Daten nicht mit einem Server Prozess
	über ein Netzwerk-Socket zur Verfügung gestellt werden, sondern
	die Engine in einer meist dynamisch verlinkten System-Library,
	implementiert ist. Die Daten werden daher auch nicht vom Server
	verwaltet, sondern befinden sich in einer ganz gewöhnlichen
	Datei, die an einem Beliebigen Ort abgelegt werden kann.

	\\
SQLAlchemy

	& Das SQLAlchemy Projekt bietet einen sogenannten Object Relational
	Mapper für Datenobjekte an. Die Software ist sehr gut durchdacht und
	bietet ein umfassendes Feature-Paket.

	\\
Pyramid

	& Das Pyramid Web Application Framework wurde unter anderem von
	ehemaligen Zope-Entwicklern programmiert und ist ebenfalls sehr gut
	durchdacht und dokumentiert.

	\\
Paste

	& Ein bereits etwas älteres Tool-Paket von Ian Bicking, das
	u.a. von Pyramid verwendet wird und ein sehr nützlichen
	deployment tool bietet, mit dem sich auf einfache
	weise ein UNIX Daemon Prozess realisieren lässt.

	Dieses Tool findet im Worker Daemon Verwendung.

	\\
Buildbot

	& Um zu gewährleisten, dass nach grösseren Änderungen an der
	Software (immer noch) alles funktioniert wie geplant, setzt man
	in der Software-Entwicklung immer mehr auf sogenannte Continous-
	Integration. Die u.U. von mehreren Entwicklern geschriebenen
	Code-Teile werden vom CI-System, z.B. Buildbot, laufend
	getestet und Test-Failures oder Errors werden gut sichtbar
	angezeigt, damit das Problem so schnell wie möglich behoben
	werden kann.

	Für die Buildbot Software wurde ein kleines Trac Plugin
	programmiert, welches den Build-Status laufend auf der
	Projekt-Homepage anzeigt.

	\\ 
Sphinx

	& Das Sphinx Dokumenten-Verarbeitungs-System kommt unter anderem
	bei der Python Software Foundation zum Einsatz. Es generiert dort
	die API-Dokumentations-Seiten. Das tut es auch in diesem Projekt
	und zwar werden die Dokument-Inhalte mit dem autodoc Plugin direkt
	aus den Quellcode-Docstrings extrahiert.

	\\
Bash

	& Die Bash-Shell ist ein sehr nützliches Tool, um einfache
	"Kommandolisten" in Scripts oder auch Funktionen zu kapseln.

	Bash Scripts wurden u.a. eingesetzt, um stündlich den Inhalt
	des lokalen Quellcode-Repositories mit einem zweiten Server,
	dessen Festplattenihalt automatisch gesichtert wird, abzugleichen.

	\\
Git

	& Das Git Quellcodeverwaltungssystem basiert auf einer genialen
	Daten-Architektur. Es bietet schier unbegrenzte Möglichkeiten,
	zur Dokumentation des Entwicklunsprozesses und ermöglicht so
	die zeilengenaue Nachvollziehbarkeit, der Entstehung des
	Software-Quellcodes.

	Das System wurde unter anderem eingesetzt um im umfangreichen
	Quellcodearchiv die Übersicht über die Autorenschaft jeder einzelnen
	Zeile zu behalten ('git commit --author=...' / 'git blame').

	\\
Apache ~/~mod\_wsgi

	& Der Apache HTTP Server ist ein weit verbreiteter Web-Server.
	Er läuft zuverlässig und ist einfach konfigurierbar.

	Er wurde eingesetzt, um in Verbindung mit mod\_wsgi, die Applikations-
	Webseite zu generieren. WSGI steht für Web Server Gateway Interface.
	Ein Standard, der die Schnittstelle zwischen Python Programmen und
	dem Apache Webserver definiert.

	\\
jQuery

	& Das von John Resig ins leben gerufene JQuery Projekt erfreut sich
	bereits seit einigen Jahren grosser Beliebtheit. Es ist eine
	Javascript Library, die dem Entwicklervor allem den Zugang zum DOM,
	dem Objektmodell einer Webseite im Browser, erleichtert.

	Die Library wurde für diverse Zwecke direkt eingesetzt und wird
	zudem von vielen anderen eingesetzten Libraries als Abhängigkeit
	vorausgesetzt.

	\\
Backbone.js

	& Dies ist eine Javascript Library, mit deren Hilfe Software-
	Objekte auf Client-Seite sauber modelliert und vor allem sehr
	bequem, über ein REST-Interface, automatisch vom Server
	aktualisiert werden können. Durch die Verwendung des Observer
	Patterns werden dann die Views laufend aktualisiert.

	\\
plupload

	& Der Upload von Datein mit einem Browser zum Server Lässt sich
	im Grunde genommen leicht realiesieren. Um die User Expierience
	allerdings möglichst angenehm zu gestalten, ist jedoch beispielsweise
	die Anzeige des Upload-Status fast Pflicht. Bei der Realisierung
	solcher Details findet man sich schnell in einem grossen Haufen
	kleiner zwar lösbarer, aber Zeitraubender Details. Diese Detailarbeit
	wurde vom plupload Projekt erledigt und die Software steht frei zur
	Verfügung. Wenn die Software genügend Sponsoren findet, sollte
	das Problem damit für die nächsten paar Jahre gelöst sein.

	\\
Python \nohyphenate{logging}

	& Wird verwendet um Diagnosemessages zu Protokollieren.

	\\
Docopt

	& Ein geniales neuartiges Tool zur programmierung von
	Kommandozeileninterfaces.

	\\
Twitter \nohyphenate{Bootstrap}

	& Ein solides Grundgerüst für alle Arten von Webseiten.

	\\
Zope \nohyphenate{Page-Templates}

	& Ein gut funktionierendes HTML-Templating System.

	\\
RESTfull API

	& Transport von JSON Daten via HTTP GET, POST, PUT und DELETE
	requests.

	\\
TopHat

	& Führt Bowtie aus und generiert aus einem FASTQ und einem
	FASTA input File einen fertigen BAM Track.

	\\
Bowtie2

	& Ordner die Short Reads der entsprechenden stelle im Genom zu.

	\\
samtools

	& Wandelt SAM in BAM, und umgekehrt um. Wird von TopHat und pysam
	benötigt.

	\\
pysam

	& Bietet eine Python API zur Verarbeitung von SAM/BAM Daten.

	\\
Biopython

	& Bietet Python API Bridges zu den NCBI eutilities und für den
	Umgang mit Genbank, Fasta und anderen bioinformatischen Datenformaten.

	\\
"Kent~tree"

	& Bietet nuben dem nicht lokal verwendeten Genome Browser
	einige Tools zur Datenumwandlung, insbesondere wigToBigWig u.a.

	\\
sra\_sdk

	& Der Offizielle Toolkit für die Umwandlung von .sra in .fastq Daten.

	\\
bcbb

	& Ein Code Tree, der unter anderem ein bam\_to\_wiggle.py Skript
	beinhaltet, mit dem der Coverage Track generiert wird.

	\\
trac

	& Wird verwendet für die Koordination der Entwicklung. Bietet
	ein gut funktionierendes Wiki System.

	\\
transterm\_hp

	& Sucht eine Basensequenz nach potentiellen Hairpin-Terminatoren ab.

	\\
s3cmd

	& Ist ein Python Programm und Library, die verwendet werden kann um
	Daten in die Amazon S3 Cloud zu transferieren.

	\\
nosetests

	& Eine Erweiterung des Unittest Paketes.

	\\
Debian Gnu/Linux

	& Eine bekannte stabile UNIX Distribution.

	\\
PyGit

	& Bietet eine API zu Git Source Code Repositories. Wird u.a. dazu
	verwendet, die Autorenschaft der einzelnen Files im Source-Code Tree
	zu dokumentieren.

	\\
Galaxy

	& Ein Projekt der Penn-State Univerity zur online RNA-seq
	Datenverarbeitung.

	\\
\end{longtable}

\newpage
\section{Anhang}
%        ======
\renewcommand\stctitle{Inhalt}
\secttoc
\newpage
%
\subsection{Abbildungen}
%           ------------
%
\begin{figure}[h]\centering
\fbox{\includegraphics[scale=0.26]{att/DomainModel}}
\caption[Domain Model]{
	Das geplante Domain-Modell.
	Die Feature-Predictions/-Predictors wurden ohne Persistente
	Datenbankobjekte implementiert und bestehen nur aus
	Daten- bzw. Programm-Files.
}
\label{fig:domainmodel}
\end{figure}
%
\begin{figure}[h]\centering
\fbox{\includegraphics{img/overview_architektur}}
\caption[Applikationsarchitektur]{
	Übersicht der Architektur der RNA-Seqlyze Applikation.
	Zuunterst die Konfigurations- und Datenbank- Dateien.
	In der Mitte die Kernfunktionalität, mit SQLAlchemy
	als \ref{glo:ORM}{Object-Relational Mapper}.
        Darüber die einzelnen Schnittstellen.
	Dann die von den Schnittstellen verwendeten Protokolle.
	Zuoberst die den Code ausführenden Prozesse.
}
\label{fig:arch}
\end{figure}
%
\begin{figure}[h]\centering
\fbox{\includegraphics{img/screen1}}
\caption[Screenshot 1]{
	Darstellung einer bereits beendeten Analyse. Der graue Hintergrund
	der Log-Ausgaben des letzten Analyseschrittes zeigt an, dass die
	Analyse beendet ist. Unter der Überschrift "Results" finden sich
	ein Link zum UCSC Genom Browser, wo die Resultate angezeigt werden
	können und ein Link zu einer Genbank Datei, in der die gefundenen
	Operons annotiert wurden.
}
\label{fig:screen1}
\end{figure}
%
\begin{figure}[h]\centering
\fbox{\includegraphics{img/screen2}}
\caption[Screenshot 2]{
	Starten einer neuen Analyse. Benötigt werden Short Read Daten und
	die Referenzsequenz. Für beide Inputs kann entweder die NCBI
	Identifikationsnummer angegeben oder eine Datei direkt
	hochgeladen werden werden.
}
\label{fig:screen2}
\end{figure}
%
\begin{figure}[h]\centering
\fbox{\includegraphics{img/screen3}}
\caption[Screenshot 3]{
	UCSC Browser.
}
\label{fig:screen3}
\end{figure}
%
\FloatBarrier
\subsection{Quellcode}
%           ---------
\input{sourcecode}
\paragraphmark{}
\subsection{Software Requirement Specification}
%           ----------------------------------
\hbox{\hskip -1cm\fbox{\includegraphics[scale=0.78,page=1]{att/SRS03}}}
\hbox{\hskip -1.28cm\fbox{\includegraphics[scale=0.8,page=2]{att/SRS03}}}
\hbox{\hskip -1.28cm\fbox{\includegraphics[scale=0.8,page=3]{att/SRS03}}}
\hbox{\hskip -1.28cm\fbox{\includegraphics[scale=0.8,page=4]{att/SRS03}}}
\hbox{\hskip -1.28cm\fbox{\includegraphics[scale=0.8,page=5]{att/SRS03}}}
\hbox{\hskip -1.28cm\fbox{\includegraphics[scale=0.8,page=6]{att/SRS03}}}
\break
\subsection{Glossar}
%           -------
\begin{tabularx}{\textwidth}{lX}
	  RNA-seq
	& Next-generation Sequenzierungs-Technologe angewendet auf
          das Profiling kompletter Transkriptome
\\
          \label{glo:ORM}
	  Object Relational Mapper
	& Ein Programmbibliothek, die automatisch die von einer Software
          verwendeten {\em Business-} bzw. {\em Domain-} Objekte in
          einer Datenbank persistiert.
\\
\end{tabularx}
%\subsection{Quellenverzeichnis}
%            ------------------
\nocite{*}
\ifxetex
	\printbibliography[
		title=Quellenverzeichnis,
		heading=subbibnumbered,
	]
\else
	\bibliographystyle{plain}
	\bibliography{Genomics}
\fi
\end{document}
% vim: tw=80:fo+=w
